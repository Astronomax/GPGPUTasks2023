## Задание 1
```
y1[n] = x[n - 1] + x[n] + x[n + 1]
```
В первом случае y1[i] могут вычисляться параллельно, потому что y1[i] зависит только от x[i - 1], x[i], x[i + 1], и не зависит от других значений y1[j].
```
y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```
В отличие от второго случая, где y2[i] зависит от двух предыдущих значений y2[i - 1], y2[i - 2]. y2 можно вычислять только последовательно.
## Задание 2
Из условия становится понятно, что каждый warp/wavefront расположен вдоль одной строки (для всех workitem'ов в одном warp/wavefront `get_local_id(1)` - константа, а x (`get_local_id(0)`) меняется от 0 до 31).

`(get_local_id(1) + get_local_size(1) * get_local_id(0)) % 32 = (get_local_id(1) + 32 * get_local_id(0)) % 32 = get_local_id(1) % 32 = const`

Следовательно, `idx % 32` в рамках одного warp/wavefront - константа. Значит, все потоки внутри одного warp/wavefront будут неотмаскированно выполнять одну и ту же ветку, code divergence не происходит.
## Задание 3
(a)
```
data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
```
Как мы уже знаем, в рамках одного warp/wavefront `get_local_size(0) * get_local_id(1)` - константа. Следовательно, элементы внутри одного warp/wavefront будут перебираться последовательно на отрезке `[get_local_size(0) * get_local_id(1), get_local_size(0) * get_local_id(1) + 31]`. Поскольку `sizeof(float) = 4`, то левая граница отрезка будет выравнена по 128 байтам (`get_local_size(0) * get_local_id(1) * sizeof(float) = 128 * get_local_id(1)`). Таким образом, данное обращение к памяти является coalesced, при этом на каждый warp/wavefront будет использована одна кэш линия записи. Всего для 32 warp/wavefront'ов потребуется 32 кэш линия записи.

(b)
```
data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
```
Как мы уже знаем, `get_local_id(1) = const`, т.е. `const + 32 * get_local_id(0)`, где `get_local_id(0)` меняется от 0 до 31. Т.е. мы будем записывать по одному `float` с промежутком в 128 байт между ними. Следовательно, данное обращение к памяти не является coalesced, и на каждый warp/wavefront потребуется 32 кэш линия записи, 1024 на всю рабочую группу.

(c)
В отличие от пункта `a` добавился сдвиг на 4 байта. Обращение к памяти по-прежнему будет coalesced, однако, теперь каждому warp/wavefront'у потребуется 2 кэш линии записи, 64 на всю рабочу группу.